[
  {
    "function_name": "set_bet_resolved_on_winning_choice",
    "function_definition": "CREATE OR REPLACE FUNCTION public.set_bet_resolved_on_winning_choice()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  IF NEW.winning_choice IS NOT NULL\n     AND (OLD.winning_choice IS DISTINCT FROM NEW.winning_choice OR OLD.winning_choice IS NULL) THEN\n    NEW.bet_status := 'resolved';\n    IF NEW.resolution_time IS NULL THEN\n      NEW.resolution_time := now();\n    END IF;\n  END IF;\n\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "function_name": "apply_bet_payouts",
    "function_definition": "CREATE OR REPLACE FUNCTION public.apply_bet_payouts()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_winner_count             integer := 0;\n  v_loser_count              integer := 0;\n  v_wager_each               numeric(12,2) := 0;\n  v_loser_pot                numeric(18,2) := 0;\n  v_base_share               numeric(18,2) := 0;\n  v_total_per_winner         numeric(18,2) := 0;\n  v_remainder_amt            numeric(18,2) := 0;\n  v_remainder_cents          integer := 0;\n  v_extra_cents_per_winner   integer := 0;\n  v_extra_cents_mod          integer := 0;\nBEGIN\n  IF NEW.bet_status = 'resolved'\n     AND COALESCE(OLD.bet_status, '') <> 'resolved'\n     AND NEW.winning_choice IS NOT NULL THEN\n\n    SELECT\n      COUNT(DISTINCT CASE WHEN bp.user_guess = NEW.winning_choice THEN bp.user_id END),\n      COUNT(DISTINCT CASE WHEN bp.user_guess IS NOT NULL AND bp.user_guess <> 'pass' AND bp.user_guess <> NEW.winning_choice THEN bp.user_id END)\n    INTO v_winner_count, v_loser_count\n    FROM public.bet_participations bp\n    WHERE bp.bet_id = NEW.bet_id;\n\n    IF v_winner_count = 0 THEN\n      RETURN NEW;\n    END IF;\n\n    v_wager_each := COALESCE(round(NEW.wager_amount::numeric, 2), 0);\n    v_loser_pot  := v_wager_each * v_loser_count;\n    v_base_share := trunc(v_loser_pot / v_winner_count, 2);\n    v_total_per_winner := v_wager_each + v_base_share;\n\n    v_remainder_amt   := GREATEST(v_loser_pot - (v_base_share * v_winner_count), 0);\n    v_remainder_cents := ROUND(v_remainder_amt * 100)::integer;\n    v_extra_cents_per_winner := CASE WHEN v_winner_count > 0 THEN v_remainder_cents / v_winner_count ELSE 0 END;\n    v_extra_cents_mod := CASE WHEN v_winner_count > 0 THEN v_remainder_cents % v_winner_count ELSE 0 END;\n\n    IF v_total_per_winner <> 0 OR v_remainder_cents > 0 THEN\n      WITH unique_winners AS (\n        SELECT DISTINCT bp.user_id\n        FROM public.bet_participations bp\n        WHERE bp.bet_id = NEW.bet_id\n          AND bp.user_guess = NEW.winning_choice\n      ),\n      ranked_winners AS (\n        SELECT uw.user_id,\n               (ROW_NUMBER() OVER (ORDER BY random()) - 1)::integer AS rn\n        FROM unique_winners uw\n      )\n      UPDATE public.table_members tm\n      SET balance = balance\n        + v_total_per_winner\n        + (v_extra_cents_per_winner::numeric / 100)\n        + CASE WHEN rw.rn < v_extra_cents_mod THEN 0.01 ELSE 0 END\n      FROM ranked_winners rw\n      WHERE tm.table_id = NEW.table_id\n        AND tm.user_id = rw.user_id;\n    END IF;\n\n    INSERT INTO public.resolution_history (bet_id, event_type, payload)\n    VALUES (\n      NEW.bet_id,\n      'payout',\n      jsonb_build_object(\n        'winners',         v_winner_count,\n        'losers',          v_loser_count,\n        'wager',           v_wager_each,\n        'losers_pot',      v_loser_pot,\n        'base_share',      v_base_share,\n        'remainder',       v_remainder_amt,\n        'remainder_cents', v_remainder_cents\n      )\n    );\n  END IF;\n\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "function_name": "resolution_enforce_no_winner_wash",
    "function_definition": "CREATE OR REPLACE FUNCTION public.resolution_enforce_no_winner_wash()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_winners INTEGER;\r\nBEGIN\r\n  IF NEW.bet_status = 'resolved' AND NEW.winning_choice IS NOT NULL THEN\r\n    SELECT COUNT(*) INTO v_winners\r\n    FROM public.bet_participations bp\r\n    WHERE bp.bet_id = NEW.bet_id\r\n      AND bp.user_guess = NEW.winning_choice;\r\n\r\n    IF COALESCE(v_winners, 0) = 0 THEN\r\n      -- No winners; convert to washed before AFTER triggers fire\r\n      NEW.bet_status := 'washed';\r\n      NEW.winning_choice := NULL;\r\n      NEW.resolution_time := now();\r\n\r\n      INSERT INTO public.resolution_history(bet_id, event_type, payload)\r\n      VALUES (NEW.bet_id, 'washed', jsonb_build_object('reason','resolved_no_winners'));\r\n    END IF;\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "is_user_member_of_table",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_user_member_of_table(p_table_id uuid, p_user_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n  RETURN EXISTS (\r\n    SELECT 1\r\n    FROM public.table_members tm\r\n    WHERE tm.table_id = p_table_id AND tm.user_id = p_user_id\r\n  );\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "log_bet_status_transition",
    "function_definition": "CREATE OR REPLACE FUNCTION public.log_bet_status_transition()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nBEGIN\r\n  IF (TG_OP = 'UPDATE') AND NEW.bet_status IS DISTINCT FROM OLD.bet_status THEN\r\n    INSERT INTO public.resolution_history (bet_id, event_type, payload)\r\n    VALUES (NEW.bet_id, 'status_transition', jsonb_build_object('from', OLD.bet_status, 'to', NEW.bet_status));\r\n  END IF;\r\n  RETURN NEW;\r\nEND;$function$\n"
  },
  {
    "function_name": "set_bets_pending",
    "function_definition": "CREATE OR REPLACE FUNCTION public.set_bets_pending()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  rec RECORD;\n  v_total_nonpass INTEGER;\n  v_distinct_nonpass INTEGER;\n  v_table_id uuid;\n  v_wager numeric;\nBEGIN\n  FOR rec IN\n    SELECT bp.bet_id\n    FROM public.bet_proposals bp\n    WHERE bp.bet_status = 'active'\n      AND bp.close_time IS NOT NULL\n      AND now() >= bp.close_time\n  LOOP\n    -- Participation summary for this bet\n    SELECT\n      COUNT(*) FILTER (WHERE user_guess IS NOT NULL AND user_guess <> 'pass') AS total_nonpass,\n      COUNT(DISTINCT user_guess) FILTER (WHERE user_guess IS NOT NULL AND user_guess <> 'pass') AS distinct_nonpass\n    INTO v_total_nonpass, v_distinct_nonpass\n    FROM public.bet_participations\n    WHERE bet_id = rec.bet_id;\n\n    IF v_total_nonpass = 0 OR v_distinct_nonpass = 1 THEN\n      -- Wash immediately: zero real participants (all pass/none) OR all non-pass picks are the same\n      UPDATE public.bet_proposals\n         SET bet_status = 'washed',\n             resolution_time = now()\n       WHERE bet_id = rec.bet_id\n         AND bet_status = 'active';\n    ELSE\n      -- Otherwise enter pending state and capture table_id + wager_amount\n      UPDATE public.bet_proposals\n         SET bet_status = 'pending'\n       WHERE bet_id = rec.bet_id\n         AND bet_status = 'active'\n       RETURNING table_id, wager_amount\n       INTO v_table_id, v_wager;\n\n      -- If the status flip actually happened, deduct wager from non-pass participants\n      IF FOUND THEN\n        UPDATE public.table_members tm\n           SET balance = balance - COALESCE(v_wager::double precision, 0::double precision)\n         WHERE tm.table_id = v_table_id\n           AND tm.user_id IN (\n             SELECT DISTINCT bp.user_id\n             FROM public.bet_participations bp\n             WHERE bp.bet_id = rec.bet_id\n               AND bp.user_guess IS NOT NULL\n               AND bp.user_guess <> 'pass'\n           );\n      END IF;\n    END IF;\n  END LOOP;\nEND;\n$function$\n"
  },
  {
    "function_name": "enforce_immutable_bet_participation_fields",
    "function_definition": "CREATE OR REPLACE FUNCTION public.enforce_immutable_bet_participation_fields()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  IF NEW.bet_id <> OLD.bet_id OR NEW.table_id <> OLD.table_id OR NEW.user_id <> OLD.user_id THEN\r\n    RAISE EXCEPTION 'bet_participations immutable fields (bet_id, table_id, user_id) cannot be modified';\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "is_bet_open",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_bet_open(p_bet_id uuid)\n RETURNS boolean\n LANGUAGE sql\n STABLE\nAS $function$\r\n  SELECT EXISTS (\r\n    SELECT 1\r\n    FROM public.bet_proposals bp\r\n    WHERE bp.bet_id = p_bet_id\r\n      AND bp.bet_status = 'active'::text\r\n      AND now() < bp.close_time\r\n  );\r\n$function$\n"
  },
  {
    "function_name": "handle_new_user",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_new_user()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nbegin\r\n  insert into public.users (user_id, email)\r\n  values (new.id, new.email);\r\n  return new;\r\nend;\r\n$function$\n"
  },
  {
    "function_name": "is_table_member",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_table_member(p_table_id uuid, p_user_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN EXISTS (\r\n        SELECT 1\r\n        FROM table_members tm -- Assumes 'table_members' table exists as per your schema\r\n        WHERE tm.table_id = p_table_id AND tm.user_id = p_user_id\r\n    );\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "get_table_host_user_id",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_table_host_user_id(p_table_id uuid)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$DECLARE\r\n    v_host_user_id uuid;\r\nBEGIN\r\n    SELECT host_user_id INTO v_host_user_id\r\n    FROM tables pt \r\n    WHERE pt.table_id = p_table_id;\r\n    RETURN v_host_user_id;\r\nEND;$function$\n"
  },
  {
    "function_name": "is_user_host_of_table",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_user_host_of_table(p_table_id uuid, p_user_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\nAS $function$BEGIN\r\n  RETURN EXISTS (\r\n    SELECT 1\r\n    FROM public.tables pt\r\n    WHERE pt.table_id = p_table_id AND pt.host_user_id = p_user_id\r\n  );\r\nEND;$function$\n"
  },
  {
    "function_name": "create_system_message_on_bet_washed",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_system_message_on_bet_washed()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_sys_id    uuid;\n  v_text      text;\n  v_table_id  uuid;\nBEGIN\n  IF (OLD.bet_status IS DISTINCT FROM 'washed' AND NEW.bet_status = 'washed') THEN\n    SELECT table_id\n      INTO v_table_id\n    FROM public.bet_proposals\n    WHERE bet_id = NEW.bet_id;\n\n    IF v_table_id IS NULL THEN\n      RAISE EXCEPTION 'Cannot create washed system message for bet %, table_id not found on bet_proposals', NEW.bet_id;\n    END IF;\n\n    v_text := format('Bet %s washed', left(NEW.bet_id::text, 8));\n\n    INSERT INTO public.system_messages (table_id, message_text, generated_at)\n    VALUES (v_table_id, v_text, now())\n    RETURNING system_message_id INTO v_sys_id;\n  END IF;\n\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "function_name": "set_bet_close_time",
    "function_definition": "CREATE OR REPLACE FUNCTION public.set_bet_close_time()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  -- Derive close_time from proposal_time + time_limit_seconds\r\n  NEW.close_time := NEW.proposal_time + make_interval(secs => NEW.time_limit_seconds::double precision);\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "create_system_message_on_bet_status_change",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_system_message_on_bet_status_change()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_sys_id    uuid;\n  v_text      text;\n  v_close_text text;\n  v_table_id  uuid;\nBEGIN\n  IF (OLD.bet_status IS DISTINCT FROM NEW.bet_status) THEN\n    SELECT table_id\n      INTO v_table_id\n    FROM public.bet_proposals\n    WHERE bet_id = NEW.bet_id;\n\n    IF v_table_id IS NULL THEN\n      RAISE EXCEPTION 'Cannot create status change system message for bet %, table_id not found on bet_proposals', NEW.bet_id;\n    END IF;\n\n    IF (OLD.bet_status = 'active' AND NEW.bet_status = 'pending') THEN\n      IF NEW.close_time IS NULL THEN\n        v_close_text := 'unknown';\n      ELSE\n        v_close_text := to_char(\n          (\n            'epoch'::timestamptz\n            + round(extract(epoch from NEW.close_time)) * interval '1 second'\n          ) AT TIME ZONE 'America/New_York',\n          'HH12:MI:SS AM'\n        ) || ' ET';\n      END IF;\n\n      v_text := format(\n        'Bet window for %s closed at %s',\n        left(NEW.bet_id::text, 8),\n        v_close_text\n      );\n\n      INSERT INTO public.system_messages (table_id, message_text, generated_at)\n      VALUES (v_table_id, v_text, now())\n      RETURNING system_message_id INTO v_sys_id;\n\n    ELSIF (NEW.bet_status = 'resolved' AND OLD.bet_status IS DISTINCT FROM 'resolved') THEN\n      v_text := format(\n        'Bet %s resolved — winning choice: \"%s\"',\n        left(NEW.bet_id::text, 8),\n        COALESCE(NEW.winning_choice::text, 'unknown')\n      );\n\n      INSERT INTO public.system_messages (table_id, message_text, generated_at)\n      VALUES (v_table_id, v_text, now())\n      RETURNING system_message_id INTO v_sys_id;\n    END IF;\n  END IF;\n\n  RETURN NEW;\nEND;\n$function$\n"
  }
]