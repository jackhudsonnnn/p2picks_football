[
  {
    "function_name": "enforce_immutable_table_member_fields",
    "function_definition": "CREATE OR REPLACE FUNCTION public.enforce_immutable_table_member_fields()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  IF NEW.table_id <> OLD.table_id THEN\n    RAISE EXCEPTION 'table_id is immutable on table_members';\n  END IF;\n  IF NEW.user_id <> OLD.user_id THEN\n    RAISE EXCEPTION 'user_id is immutable on table_members';\n  END IF;\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "function_name": "messages_sync_from_text_messages",
    "function_definition": "CREATE OR REPLACE FUNCTION public.messages_sync_from_text_messages()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nbegin\n  insert into public.messages (table_id, message_type, text_message_id, posted_at, created_at)\n  values (new.table_id, 'chat', new.text_message_id, new.posted_at, new.posted_at)\n  on conflict (text_message_id) do update\n    set posted_at = excluded.posted_at,\n        table_id = excluded.table_id;\n  return new;\nend;\n$function$\n"
  },
  {
    "function_name": "messages_sync_from_system_messages",
    "function_definition": "CREATE OR REPLACE FUNCTION public.messages_sync_from_system_messages()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nbegin\n  insert into public.messages (table_id, message_type, system_message_id, posted_at, created_at)\n  values (new.table_id, 'system', new.system_message_id, new.generated_at, new.generated_at)\n  on conflict (system_message_id) do update\n    set posted_at = excluded.posted_at,\n        table_id = excluded.table_id;\n  return new;\nend;\n$function$\n"
  },
  {
    "function_name": "set_bet_resolved_on_winning_choice",
    "function_definition": "CREATE OR REPLACE FUNCTION public.set_bet_resolved_on_winning_choice()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  IF NEW.winning_choice IS NOT NULL\n     AND (OLD.winning_choice IS DISTINCT FROM NEW.winning_choice OR OLD.winning_choice IS NULL) THEN\n    NEW.bet_status := 'resolved'::bet_lifecycle_status;\n    IF NEW.resolution_time IS NULL THEN\n      NEW.resolution_time := now();\n    END IF;\n  END IF;\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "function_name": "messages_sync_from_bet_proposals",
    "function_definition": "CREATE OR REPLACE FUNCTION public.messages_sync_from_bet_proposals()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nbegin\n  insert into public.messages (table_id, message_type, bet_id, posted_at, created_at)\n  values (\n    new.table_id,\n    'bet_proposal',\n    new.bet_id,\n    coalesce(new.proposal_time, now()),\n    coalesce(new.proposal_time, now())\n  )\n  on conflict (bet_id) do update\n    set posted_at = excluded.posted_at,\n        table_id  = excluded.table_id;\n  return new;\nend;\n$function$\n"
  },
  {
    "function_name": "refund_bet_points_on_wash",
    "function_definition": "CREATE OR REPLACE FUNCTION public.refund_bet_points_on_wash()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_wager_each numeric(12,2) := COALESCE(round(NEW.wager_amount::numeric, 2), 0);\n  v_participant record;\n  v_participant_count integer;\n  v_choice_count integer;\n  v_loser_pot numeric(12,2);\n  v_payout_share numeric(12,2);\nBEGIN\n  -- Count total participants for payout calculation\n  SELECT count(DISTINCT user_id)\n    INTO v_participant_count\n    FROM public.bet_participations\n   WHERE bet_id = NEW.bet_id\n     AND user_guess IS NOT NULL\n     AND user_guess <> 'No Entry';\n\n  -- Process each participant\n  FOR v_participant IN\n    SELECT DISTINCT bp.user_id, bp.user_guess\n      FROM public.bet_participations bp\n     WHERE bp.bet_id = NEW.bet_id\n       AND bp.user_guess IS NOT NULL\n       AND bp.user_guess <> 'No Entry'\n  LOOP\n    -- Count how many chose this participant's choice\n    SELECT count(DISTINCT user_id)\n      INTO v_choice_count\n      FROM public.bet_participations\n     WHERE bet_id = NEW.bet_id\n       AND user_guess = v_participant.user_guess;\n\n    -- Guard against division by zero\n    IF v_choice_count = 0 THEN\n      INSERT INTO public.resolution_history (bet_id, event_type, payload)\n      VALUES (\n        NEW.bet_id,\n        'wash_refund_error',\n        jsonb_build_object(\n          'error', 'division_by_zero',\n          'user_id', v_participant.user_id,\n          'user_guess', v_participant.user_guess\n        )\n      );\n      CONTINUE;\n    END IF;\n\n    -- Calculate the potential payout that was added to sweep_balance\n    v_loser_pot := v_wager_each * (v_participant_count - v_choice_count);\n    v_payout_share := v_wager_each + trunc(v_loser_pot / v_choice_count, 2);\n\n    -- Refund: restore bust, reverse sweep escrow\n    UPDATE public.table_members tm\n       SET bust_balance  = bust_balance + v_wager_each,\n           sweep_balance = sweep_balance - v_payout_share + v_wager_each\n     WHERE tm.table_id = NEW.table_id\n       AND tm.user_id = v_participant.user_id;\n  END LOOP;\n\n  INSERT INTO public.resolution_history (bet_id, event_type, payload)\n  VALUES (\n    NEW.bet_id,\n    'wash_refund',\n    jsonb_build_object(\n      'refunded_users', v_participant_count,\n      'wager', v_wager_each,\n      'status_from', OLD.bet_status,\n      'status_to', NEW.bet_status\n    )\n  );\n\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "function_name": "transition_bet_to_pending",
    "function_definition": "CREATE OR REPLACE FUNCTION public.transition_bet_to_pending(p_bet_id uuid)\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\n-- ── Phase 1 of the two-phase escrow model ───────────────────────────────────\n-- Called by the bet lifecycle service when a bet's close_time is reached.\n-- Validates that the bet is still active and has meaningful participation,\n-- then atomically transitions it to 'pending' and debits each participant's\n-- bust_balance (wager escrow) while crediting sweep_balance with their\n-- contingent payout share.  If insufficient distinct guesses exist, the bet\n-- is immediately washed instead.\n--\n-- Returns one of:\n--   'pending'                       — success, bet is now pending\n--   'washed_insufficient_participation' — bet washed (all same guess / no guesses)\n--   'forbidden'                     — caller is not service_role or postgres\n--   'invalid_argument'              — p_bet_id is NULL\n--   'not_found'                     — no bet with that ID\n--   'not_active'                    — bet is already past active\n--   'no_close_time'                 — close_time missing (should never happen)\n--   'too_early'                     — close_time has not elapsed yet\n-- ── end header ───────────────────────────────────────────────────────────────\nDECLARE\n  v_bet record;\n  v_total_non_no_entry integer;\n  v_distinct_non_no_entry integer;\n  v_table_id uuid;\n  v_wager numeric(12,2);\n  v_role text;\n  v_participant record;\n  v_participant_count integer;\n  v_choice_count integer;\n  v_loser_pot numeric(12,2);\n  v_payout_share numeric(12,2);\nBEGIN\n  v_role := coalesce(current_setting('request.jwt.claim.role', true), current_user);\n  IF v_role NOT IN ('service_role', 'postgres') THEN\n    RETURN 'forbidden';\n  END IF;\n\n  IF p_bet_id IS NULL THEN\n    RETURN 'invalid_argument';\n  END IF;\n\n  SELECT * INTO v_bet\n  FROM public.bet_proposals\n  WHERE bet_id = p_bet_id\n  FOR UPDATE;\n\n  IF NOT FOUND THEN\n    RETURN 'not_found';\n  END IF;\n\n  IF v_bet.bet_status <> 'active'::bet_lifecycle_status THEN\n    RETURN 'not_active';\n  END IF;\n\n  IF v_bet.close_time IS NULL THEN\n    RETURN 'no_close_time';\n  END IF;\n\n  IF now() < v_bet.close_time THEN\n    RETURN 'too_early';\n  END IF;\n\n  SELECT\n    count(*) FILTER (WHERE user_guess IS NOT NULL AND user_guess <> 'No Entry') AS total_non_no_entry,\n    count(DISTINCT user_guess) FILTER (WHERE user_guess IS NOT NULL AND user_guess <> 'No Entry') AS distinct_non_no_entry\n  INTO v_total_non_no_entry, v_distinct_non_no_entry\n  FROM public.bet_participations\n  WHERE bet_id = v_bet.bet_id;\n\n  -- Wash immediately if no real guesses or everyone picked the same option\n  -- (a one-sided bet has no payout pool to distribute)\n  IF v_total_non_no_entry = 0 OR v_distinct_non_no_entry = 1 THEN\n    UPDATE public.bet_proposals\n       SET bet_status = 'washed'::bet_lifecycle_status,\n           resolution_time = now()\n     WHERE bet_id = v_bet.bet_id\n       AND bet_status = 'active'::bet_lifecycle_status;\n    RETURN 'washed_insufficient_participation';\n  END IF;\n\n  -- Transition to pending and capture table context for balance updates\n  UPDATE public.bet_proposals\n     SET bet_status = 'pending'::bet_lifecycle_status\n   WHERE bet_id = v_bet.bet_id\n     AND bet_status = 'active'::bet_lifecycle_status\n   RETURNING table_id, round(wager_amount::numeric, 2)\n    INTO v_table_id, v_wager;\n\n  IF NOT FOUND THEN\n    RETURN 'not_active';\n  END IF;\n\n  v_participant_count := v_total_non_no_entry;\n\n  -- Phase 1 escrow: debit wager from bust_balance; credit contingent payout\n  -- share to sweep_balance.  Sweep holds the *total* potential payout\n  -- (wager + profit slice) so that apply_bet_payouts can later net it out.\n  FOR v_participant IN\n    SELECT DISTINCT bp.user_id, bp.user_guess\n      FROM public.bet_participations bp\n     WHERE bp.bet_id = v_bet.bet_id\n       AND bp.user_guess IS NOT NULL\n       AND bp.user_guess <> 'No Entry'\n  LOOP\n    SELECT count(DISTINCT user_id)\n      INTO v_choice_count\n      FROM public.bet_participations\n     WHERE bet_id = v_bet.bet_id\n       AND user_guess = v_participant.user_guess;\n\n    v_loser_pot    := v_wager * (v_participant_count - v_choice_count);\n    -- Use trunc (not round) for exact math — no IEEE-754 surprises\n    v_payout_share := v_wager + trunc(v_loser_pot / v_choice_count, 2);\n\n    UPDATE public.table_members tm\n       SET bust_balance  = bust_balance  - v_wager,\n           sweep_balance = sweep_balance + (v_payout_share - v_wager)\n     WHERE tm.table_id = v_table_id\n       AND tm.user_id  = v_participant.user_id;\n  END LOOP;\n\n  RETURN 'pending';\nEND;\n$function$\n"
  },
  {
    "function_name": "wash_bet_with_history",
    "function_definition": "CREATE OR REPLACE FUNCTION public.wash_bet_with_history(p_bet_id uuid, p_event_type text, p_payload jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_result     jsonb;\n  v_table_id   uuid;\nBEGIN\n  -- Attempt to wash: only transitions bets that are currently 'pending'\n  UPDATE public.bet_proposals\n  SET bet_status      = 'washed'::bet_lifecycle_status,\n      winning_choice  = NULL,\n      resolution_time = now()\n  WHERE bet_id     = p_bet_id\n    AND bet_status = 'pending'::bet_lifecycle_status\n  RETURNING table_id INTO v_table_id;\n\n  -- If no row was updated, the bet was not pending — return null\n  IF NOT FOUND THEN\n    RETURN NULL;\n  END IF;\n\n  -- Record history within the same transaction\n  INSERT INTO public.resolution_history (bet_id, event_type, payload)\n  VALUES (p_bet_id, p_event_type, p_payload);\n\n  v_result := jsonb_build_object(\n    'bet_id',   p_bet_id,\n    'table_id', v_table_id\n  );\n\n  RETURN v_result;\nEND;\n$function$\n"
  },
  {
    "function_name": "settle_table",
    "function_definition": "CREATE OR REPLACE FUNCTION public.settle_table(p_table_id uuid, p_user_id uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_table       record;\n  v_active_count integer;\n  v_members     jsonb;\n  v_snapshot    jsonb := '[]'::jsonb;\n  v_member      record;\n  v_settled_at  timestamptz := now();\nBEGIN\n  -- 1. Verify table exists and lock the row\n  SELECT table_id, host_user_id\n    INTO v_table\n    FROM public.tables\n   WHERE table_id = p_table_id\n   FOR UPDATE;\n\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Table not found'\n      USING ERRCODE = 'P0002';  -- no_data_found\n  END IF;\n\n  -- 2. Only the host may settle\n  IF v_table.host_user_id <> p_user_id THEN\n    RAISE EXCEPTION 'Only the table host can settle the table'\n      USING ERRCODE = 'P0003';\n  END IF;\n\n  -- 3. No active or pending bets\n  SELECT count(*)\n    INTO v_active_count\n    FROM public.bet_proposals\n   WHERE table_id = p_table_id\n     AND bet_status IN ('active'::bet_lifecycle_status, 'pending'::bet_lifecycle_status);\n\n  IF v_active_count > 0 THEN\n    RAISE EXCEPTION 'Cannot settle table: % bet(s) are still active or pending', v_active_count\n      USING ERRCODE = 'P0004';\n  END IF;\n\n  -- 4. Snapshot current balances\n  SELECT jsonb_agg(\n    jsonb_build_object(\n      'userId', tm.user_id,\n      'bustBalanceBefore', tm.bust_balance,\n      'pushBalanceBefore', tm.push_balance,\n      'sweepBalanceBefore', tm.sweep_balance\n    )\n  )\n    INTO v_snapshot\n    FROM public.table_members tm\n   WHERE tm.table_id = p_table_id;\n\n  IF v_snapshot IS NULL THEN\n    v_snapshot := '[]'::jsonb;\n  END IF;\n\n  -- 5. Settle: bust -= push, sweep -= push, push = 0\n  UPDATE public.table_members tm\n     SET bust_balance  = bust_balance - push_balance,\n         sweep_balance = sweep_balance - push_balance,\n         push_balance  = 0\n   WHERE tm.table_id = p_table_id;\n\n  -- 6. Record settlement event\n  INSERT INTO public.table_settlements (table_id, settled_by, settled_at, balance_snapshot)\n  VALUES (p_table_id, p_user_id, v_settled_at, v_snapshot);\n\n  -- 7. Return result\n  RETURN jsonb_build_object(\n    'tableId', p_table_id,\n    'settledAt', v_settled_at,\n    'memberCount', jsonb_array_length(v_snapshot),\n    'balances', v_snapshot\n  );\nEND;\n$function$\n"
  },
  {
    "function_name": "create_table_with_host",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_table_with_host(p_table_name text, p_host_user_id uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_table_id   uuid;\n  v_created_at timestamptz;\nBEGIN\n  -- Validate\n  IF p_table_name IS NULL OR length(trim(p_table_name)) < 1 THEN\n    RAISE EXCEPTION 'Table name is required'\n      USING ERRCODE = 'P0005';\n  END IF;\n\n  -- Insert table\n  INSERT INTO public.tables (table_name, host_user_id)\n  VALUES (trim(p_table_name), p_host_user_id)\n  RETURNING table_id, created_at INTO v_table_id, v_created_at;\n\n  -- Insert host as first member\n  INSERT INTO public.table_members (table_id, user_id)\n  VALUES (v_table_id, p_host_user_id);\n\n  RETURN jsonb_build_object(\n    'table_id', v_table_id,\n    'table_name', trim(p_table_name),\n    'host_user_id', p_host_user_id,\n    'created_at', v_created_at\n  );\nEND;\n$function$\n"
  },
  {
    "function_name": "resolution_enforce_no_winner_wash",
    "function_definition": "CREATE OR REPLACE FUNCTION public.resolution_enforce_no_winner_wash()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$DECLARE\n  v_winners INTEGER;\nBEGIN\n  IF NEW.bet_status = 'resolved'::bet_lifecycle_status AND NEW.winning_choice IS NOT NULL THEN\n    SELECT COUNT(*) INTO v_winners\n    FROM public.bet_participations bp\n    WHERE bp.bet_id = NEW.bet_id\n      AND bp.user_guess = NEW.winning_choice;\n\n    IF COALESCE(v_winners, 0) = 0 THEN\n      NEW.bet_status := 'washed'::bet_lifecycle_status;\n      NEW.winning_choice := NULL;\n      NEW.resolution_time := now();\n\n      INSERT INTO public.resolution_history(bet_id, event_type, payload)\n      VALUES (NEW.bet_id, 'washed', jsonb_build_object('reason','Nobody chose the correct choice'));\n    END IF;\n  END IF;\n  RETURN NEW;\nEND;$function$\n"
  },
  {
    "function_name": "is_user_member_of_table",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_user_member_of_table(p_table_id uuid, p_user_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n  RETURN EXISTS (\r\n    SELECT 1\r\n    FROM public.table_members tm\r\n    WHERE tm.table_id = p_table_id AND tm.user_id = p_user_id\r\n  );\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "accept_friend_request",
    "function_definition": "CREATE OR REPLACE FUNCTION public.accept_friend_request(p_request_id uuid, p_user_id uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_request     record;\n  v_other_user  uuid;\n  v_responded   timestamptz := now();\nBEGIN\n  -- 1. Load and lock the request\n  SELECT request_id, sender_user_id, receiver_user_id, status\n    INTO v_request\n    FROM public.friend_requests\n   WHERE request_id = p_request_id\n   FOR UPDATE;\n\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Friend request not found'\n      USING ERRCODE = 'P0002';\n  END IF;\n\n  -- 2. Only the receiver can accept\n  IF v_request.receiver_user_id <> p_user_id THEN\n    RAISE EXCEPTION 'Only the receiver can accept this request'\n      USING ERRCODE = 'P0003';\n  END IF;\n\n  -- 3. Must be pending\n  IF v_request.status <> 'pending'::friend_request_status THEN\n    RAISE EXCEPTION 'Request is no longer pending'\n      USING ERRCODE = 'P0006';\n  END IF;\n\n  -- 4. Update to accepted\n  UPDATE public.friend_requests\n     SET status = 'accepted'::friend_request_status,\n         responded_at = v_responded\n   WHERE request_id = p_request_id;\n\n  -- 5. Insert friendship row (idempotent — skip if already friends)\n  v_other_user := v_request.sender_user_id;\n\n  INSERT INTO public.friends (user_id1, user_id2)\n  VALUES (p_user_id, v_other_user)\n  ON CONFLICT DO NOTHING;\n\n  -- Also try the reverse direction in case the PK ordering matters\n  INSERT INTO public.friends (user_id1, user_id2)\n  VALUES (v_other_user, p_user_id)\n  ON CONFLICT DO NOTHING;\n\n  RETURN jsonb_build_object(\n    'request_id', p_request_id,\n    'sender_user_id', v_request.sender_user_id,\n    'receiver_user_id', v_request.receiver_user_id,\n    'status', 'accepted',\n    'responded_at', v_responded\n  );\nEND;\n$function$\n"
  },
  {
    "function_name": "apply_bet_payouts",
    "function_definition": "CREATE OR REPLACE FUNCTION public.apply_bet_payouts()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\n-- ── Phase 2 of the two-phase escrow model ───────────────────────────────────\n-- Fired AFTER UPDATE on bet_proposals when bet_status transitions to\n-- 'resolved' and winning_choice is set.\n--\n-- At this point each participant already has:\n--   bust_balance  reduced by their wager    (from Phase 1)\n--   sweep_balance holding their contingent  (from Phase 1)\n--\n-- Phase 2 actions:\n--   Winners: restore bust_balance by full payout_share, record net profit\n--            in push_balance, clear the sweep_balance adjustment.\n--   Losers:  record net loss in push_balance, clear sweep_balance\n--            contingent that will never materialise.\n--\n-- Penny-level remainder (from integer division) is distributed one cent at\n-- a time to randomly ordered winners so totals are always exact.\n-- ── end header ───────────────────────────────────────────────────────────────\nDECLARE\n  v_winner_count             integer := 0;\n  v_loser_count              integer := 0;\n  v_wager_each               numeric(12,2) := 0;\n  v_loser_pot                numeric(18,2) := 0;\n  v_base_share               numeric(18,2) := 0;\n  v_total_per_winner         numeric(18,2) := 0;\n  v_remainder_amt            numeric(18,2) := 0;\n  v_remainder_cents          integer := 0;\n  v_extra_cents_per_winner   integer := 0;\n  v_extra_cents_mod          integer := 0;\n  v_participant_count        integer := 0;\n  v_participant record;\n  v_choice_count integer;\n  v_potential_payout numeric(18,2);\n  v_potential_loser_pot numeric(18,2);\nBEGIN\n  IF NEW.bet_status = 'resolved'::bet_lifecycle_status\n     AND OLD.bet_status IS DISTINCT FROM 'resolved'::bet_lifecycle_status\n     AND NEW.winning_choice IS NOT NULL THEN\n\n    SELECT\n      COUNT(DISTINCT CASE WHEN bp.user_guess = NEW.winning_choice THEN bp.user_id END),\n      COUNT(DISTINCT CASE WHEN bp.user_guess IS NOT NULL AND bp.user_guess <> 'No Entry' AND bp.user_guess <> NEW.winning_choice THEN bp.user_id END),\n      COUNT(DISTINCT CASE WHEN bp.user_guess IS NOT NULL AND bp.user_guess <> 'No Entry' THEN bp.user_id END)\n    INTO v_winner_count, v_loser_count, v_participant_count\n    FROM public.bet_participations bp\n    WHERE bp.bet_id = NEW.bet_id;\n\n    IF v_winner_count = 0 THEN\n      RETURN NEW;\n    END IF;\n\n    v_wager_each := COALESCE(round(NEW.wager_amount::numeric, 2), 0);\n    v_loser_pot  := v_wager_each * v_loser_count;\n    v_base_share := trunc(v_loser_pot / v_winner_count, 2);\n    v_total_per_winner := v_wager_each + v_base_share;\n\n    -- Distribute remainder cents one at a time in random winner order\n    v_remainder_amt          := GREATEST(v_loser_pot - (v_base_share * v_winner_count), 0);\n    v_remainder_cents        := ROUND(v_remainder_amt * 100)::integer;\n    v_extra_cents_per_winner := CASE WHEN v_winner_count > 0 THEN v_remainder_cents / v_winner_count ELSE 0 END;\n    v_extra_cents_mod        := CASE WHEN v_winner_count > 0 THEN v_remainder_cents % v_winner_count ELSE 0 END;\n\n    IF v_total_per_winner <> 0 OR v_remainder_cents > 0 THEN\n      WITH unique_winners AS (\n        SELECT DISTINCT bp.user_id\n        FROM public.bet_participations bp\n        WHERE bp.bet_id = NEW.bet_id\n          AND bp.user_guess = NEW.winning_choice\n      ),\n      ranked_winners AS (\n        SELECT uw.user_id,\n               (ROW_NUMBER() OVER (ORDER BY random()) - 1)::integer AS rn\n        FROM unique_winners uw\n      )\n      UPDATE public.table_members tm\n      SET bust_balance = bust_balance\n        + v_total_per_winner\n        + (v_extra_cents_per_winner::numeric / 100)\n        + CASE WHEN rw.rn < v_extra_cents_mod THEN 0.01 ELSE 0 END,\n          push_balance = push_balance\n        + (v_total_per_winner - v_wager_each)\n        + (v_extra_cents_per_winner::numeric / 100)\n        + CASE WHEN rw.rn < v_extra_cents_mod THEN 0.01 ELSE 0 END,\n          sweep_balance = sweep_balance\n        - CASE WHEN rw.rn < v_extra_cents_mod THEN 0 ELSE 0.01 END\n      FROM ranked_winners rw\n      WHERE tm.table_id = NEW.table_id\n        AND tm.user_id = rw.user_id;\n    END IF;\n\n    -- Clear loser sweep contingent and record their push_balance loss\n    FOR v_participant IN\n      SELECT DISTINCT bp.user_id, bp.user_guess\n        FROM public.bet_participations bp\n       WHERE bp.bet_id = NEW.bet_id\n         AND bp.user_guess IS NOT NULL\n         AND bp.user_guess <> 'No Entry'\n    LOOP\n      SELECT count(DISTINCT user_id)\n        INTO v_choice_count\n        FROM public.bet_participations\n       WHERE bet_id = NEW.bet_id\n         AND user_guess = v_participant.user_guess;\n\n      v_potential_loser_pot := v_wager_each * (v_participant_count - v_choice_count);\n      v_potential_payout    := v_wager_each + trunc(v_potential_loser_pot / NULLIF(v_choice_count, 0), 2);\n\n      IF v_participant.user_guess = NEW.winning_choice THEN\n        -- Winners handled above via the CTE UPDATE; nothing more to do here\n        NULL;\n      ELSE\n        UPDATE public.table_members tm\n        SET push_balance  = push_balance  - v_wager_each,\n            sweep_balance = sweep_balance - COALESCE(v_potential_payout, 0)\n        WHERE tm.table_id = NEW.table_id\n          AND tm.user_id  = v_participant.user_id;\n      END IF;\n    END LOOP;\n\n    INSERT INTO public.resolution_history (bet_id, event_type, payload)\n    VALUES (\n      NEW.bet_id,\n      'payout',\n      jsonb_build_object(\n        'winners',         v_winner_count,\n        'losers',          v_loser_count,\n        'wager',           v_wager_each,\n        'losers_pot',      v_loser_pot,\n        'base_share',      v_base_share,\n        'remainder',       v_remainder_amt,\n        'remainder_cents', v_remainder_cents\n      )\n    );\n  END IF;\n\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "function_name": "log_bet_status_transition",
    "function_definition": "CREATE OR REPLACE FUNCTION public.log_bet_status_transition()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nBEGIN\r\n  IF (TG_OP = 'UPDATE') AND NEW.bet_status IS DISTINCT FROM OLD.bet_status THEN\r\n    INSERT INTO public.resolution_history (bet_id, event_type, payload)\r\n    VALUES (NEW.bet_id, 'status_transition', jsonb_build_object('from', OLD.bet_status, 'to', NEW.bet_status));\r\n  END IF;\r\n  RETURN NEW;\r\nEND;$function$\n"
  },
  {
    "function_name": "create_system_message_on_bet_status_change",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_system_message_on_bet_status_change()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$declare\n  v_table_id uuid;\n  v_lines text[];\n  v_total_participants integer := 0;\n  v_option record;\n  v_wager numeric := coalesce(NEW.wager_amount, 0);\n  v_total_pot numeric;\n  v_share numeric;\n  v_profit numeric;\n  v_odds_text text;\n  v_odds_value numeric;\nbegin\n  if (OLD.bet_status is distinct from NEW.bet_status) then\n    select table_id\n      into v_table_id\n    from public.bet_proposals\n    where bet_id = NEW.bet_id;\n\n    if v_table_id is null then\n      raise exception\n        'Cannot create status change system message for bet %, table_id not found on bet_proposals',\n        NEW.bet_id;\n    end if;\n\n    if (OLD.bet_status = 'active'::bet_lifecycle_status and NEW.bet_status = 'pending'::bet_lifecycle_status) then\n      select count(distinct user_id)\n        into v_total_participants\n      from public.bet_participations\n      where bet_id = NEW.bet_id\n        and user_guess is not null\n        and user_guess <> 'No Entry';\n\n      v_lines := array[\n        format(E'Bet #%s pending', left(NEW.bet_id::text, 8))\n      ];\n\n      for v_option in\n        select user_guess as option_label,\n               count(distinct user_id) as pick_count\n        from public.bet_participations\n        where bet_id = NEW.bet_id\n          and user_guess is not null\n          and user_guess <> 'No Entry'\n        group by user_guess\n        order by user_guess\n      loop\n        if v_option.pick_count > 0 and v_total_participants > 0 then\n          v_total_pot := v_wager * (v_total_participants - v_option.pick_count);\n          v_share := v_wager + (v_total_pot / v_option.pick_count);\n          v_profit := v_share - v_wager;\n\n          if v_option.pick_count = v_total_participants then\n            v_odds_text := '--';\n          else\n            if v_option.pick_count > (v_total_participants / 2.0) then\n              v_odds_value := -100 / ((v_total_participants - v_option.pick_count)::numeric / v_option.pick_count);\n              v_odds_text := to_char(v_odds_value, 'FM9999');\n            else\n              v_odds_value := ((v_total_participants - v_option.pick_count)::numeric / v_option.pick_count) * 100;\n              v_odds_text := to_char(v_odds_value, 'FM+9999');\n            end if;\n          end if;\n\n          v_lines := array_append(v_lines, format(\n            E'%s (%s):\\n  %s pt payout\\n  %s participant(s)',\n            v_option.option_label,\n            v_odds_text,\n            to_char(v_share, 'FM999G999D00'),\n            to_char(v_option.pick_count, 'FM9999')\n          ));\n        end if;\n      end loop;\n\n      if array_length(v_lines, 1) = 2 then\n        v_lines[2] := v_lines[2] || E'\\n\\nNo eligible picks — bet will wash if this stands.';\n        insert into public.system_messages (table_id, message_text, generated_at)\n        values (v_table_id, array_to_string(v_lines, E'\\n'), now());\n      else\n        insert into public.system_messages (table_id, message_text, generated_at)\n        values (v_table_id, array_to_string(v_lines, E'\\n\\n'), now());\n      end if;\n\n    elsif (NEW.bet_status = 'resolved'::bet_lifecycle_status and OLD.bet_status is distinct from 'resolved'::bet_lifecycle_status) then\n      insert into public.system_messages (table_id, message_text, generated_at)\n      values (\n        v_table_id,\n        format(\n          E'Bet #%s resolved\\n\\nwinning choice: \\\"%s\\\"',\n          left(NEW.bet_id::text, 8),\n          coalesce(NEW.winning_choice::text, 'unknown')\n        ),\n        now()\n      );\n    end if;\n  end if;\n\n  return NEW;\nend;$function$\n"
  },
  {
    "function_name": "set_bets_pending",
    "function_definition": "CREATE OR REPLACE FUNCTION public.set_bets_pending()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$DECLARE\n  rec RECORD;\nBEGIN\n  FOR rec IN\n    SELECT bp.bet_id\n      FROM public.bet_proposals bp\n     WHERE bp.bet_status = 'active'::bet_lifecycle_status\n       AND bp.close_time IS NOT NULL\n       AND now() >= bp.close_time\n  LOOP\n    PERFORM public.transition_bet_to_pending(rec.bet_id);\n  END LOOP;\nEND;$function$\n"
  },
  {
    "function_name": "enforce_immutable_bet_participation_fields",
    "function_definition": "CREATE OR REPLACE FUNCTION public.enforce_immutable_bet_participation_fields()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  IF NEW.bet_id <> OLD.bet_id OR NEW.table_id <> OLD.table_id OR NEW.user_id <> OLD.user_id THEN\n    RAISE EXCEPTION 'bet_participations immutable fields (bet_id, table_id, user_id) cannot be modified';\n  END IF;\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "function_name": "handle_new_user",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_new_user()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nbegin\r\n  insert into public.users (user_id, email)\r\n  values (new.id, new.email);\r\n  return new;\r\nend;\r\n$function$\n"
  },
  {
    "function_name": "is_bet_open",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_bet_open(p_bet_id uuid)\n RETURNS boolean\n LANGUAGE sql\n STABLE SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\n  SELECT EXISTS (\n    SELECT 1\n    FROM public.bet_proposals bp\n    WHERE bp.bet_id = p_bet_id\n      AND bp.bet_status = 'active'::bet_lifecycle_status\n      AND now() < bp.close_time\n  );\n$function$\n"
  },
  {
    "function_name": "get_table_host_user_id",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_table_host_user_id(p_table_id uuid)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$DECLARE\r\n    v_host_user_id uuid;\r\nBEGIN\r\n    SELECT host_user_id INTO v_host_user_id\r\n    FROM tables pt \r\n    WHERE pt.table_id = p_table_id;\r\n    RETURN v_host_user_id;\r\nEND;$function$\n"
  },
  {
    "function_name": "is_user_host_of_table",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_user_host_of_table(p_table_id uuid, p_user_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\nAS $function$BEGIN\r\n  RETURN EXISTS (\r\n    SELECT 1\r\n    FROM public.tables pt\r\n    WHERE pt.table_id = p_table_id AND pt.host_user_id = p_user_id\r\n  );\r\nEND;$function$\n"
  },
  {
    "function_name": "create_system_message_on_bet_washed",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_system_message_on_bet_washed()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_sys_id    uuid;\n  v_text      text;\n  v_table_id  uuid;\n  v_payload   jsonb := '{}'::jsonb;\n  v_reason    text;\nBEGIN\n  IF (OLD.bet_status IS DISTINCT FROM 'washed'::bet_lifecycle_status AND NEW.bet_status = 'washed'::bet_lifecycle_status) THEN\n    SELECT table_id\n      INTO v_table_id\n    FROM public.bet_proposals\n    WHERE bet_id = NEW.bet_id;\n\n    IF v_table_id IS NULL THEN\n      RAISE EXCEPTION 'Cannot create washed system message for bet %, table_id not found on bet_proposals', NEW.bet_id;\n    END IF;\n\n    -- Prefer a reason from the latest washed history entry (e.g., “Nobody chose the correct choice”)\n    SELECT payload\n      INTO v_payload\n    FROM public.resolution_history\n    WHERE bet_id = NEW.bet_id\n      AND event_type = 'washed'\n    ORDER BY created_at DESC\n    LIMIT 1;\n\n    v_reason := COALESCE(\n      v_payload->>'reason',\n      v_payload->>'explanation',\n      v_payload->>'wash_reason',\n      v_payload->>'wash_reason_text',\n      v_payload->>'outcome_detail',\n      'Not enough participants'\n    );\n\n    v_text := format(E'Bet #%s washed\\n\\n%s', left(NEW.bet_id::text, 8), v_reason);\n\n    INSERT INTO public.system_messages (table_id, message_text, generated_at)\n    VALUES (v_table_id, v_text, now())\n    RETURNING system_message_id INTO v_sys_id;\n  END IF;\n\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "function_name": "set_bet_close_time",
    "function_definition": "CREATE OR REPLACE FUNCTION public.set_bet_close_time()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  NEW.close_time := NEW.proposal_time + make_interval(secs => NEW.time_limit_seconds::double precision);\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "function_name": "touch_table_last_activity",
    "function_definition": "CREATE OR REPLACE FUNCTION public.touch_table_last_activity()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nbegin\n  if new.table_id is not null then\n    update public.tables\n       set last_activity_at = now()\n     where table_id = new.table_id;\n  end if;\n  return new;\nend;\n$function$\n"
  }
]