import { getSupabaseAdmin } from '../../supabaseClient';
import { createLogger } from '../../utils/logger';
import { captureLiveInfoSnapshot } from './liveInfoSnapshot';

const logger = createLogger('washService');

export interface WashOptions {
  betId: string;
  payload: Record<string, unknown>;
  explanation: string;
  eventType: string;
  modeLabel: string;
}

/**
 * Atomically washes a bet and records its history in a single database
 * transaction via the `wash_bet_with_history` RPC.
 *
 * Previously this was two separate calls (UPDATE + INSERT) which could leave
 * orphaned state if the server crashed between them.
 *
 * The "Bet #xxx washed" system message is generated by the DB trigger
 * trg_bet_proposals_washed_msg → create_system_message_on_bet_washed().
 * Do NOT insert system_messages here — that would produce a duplicate.
 */
export async function washBetWithHistory({ betId, payload, explanation, eventType, modeLabel }: WashOptions): Promise<void> {
  try {
    const supabase = getSupabaseAdmin();
    const fullPayload = { outcome: 'wash', mode: modeLabel, ...payload };

    const { data, error } = await supabase.rpc('wash_bet_with_history', {
      p_bet_id: betId,
      p_event_type: eventType,
      p_payload: fullPayload,
    });

    if (error) {
      logger.error({ betId, error: error.message }, 'wash_bet_with_history RPC error');
      return;
    }

    if (!data) {
      logger.warn({ betId }, 'wash skipped; bet not pending');
      return;
    }

    // Fire-and-forget: capture a live-info snapshot for the washed bet.
    // Uses the mode label from the payload; the snapshot fn will fetch
    // the full bet row to determine modeKey and league.
    captureLiveInfoSnapshotForWash(betId, fullPayload.mode, explanation);
  } catch (err) {
    logger.error({ betId, error: err instanceof Error ? err.message : String(err) }, 'wash bet error');
  }
}

/**
 * Best-effort snapshot capture for the standalone wash path.
 * Fetches the bet row to determine modeKey and league, then delegates
 * to the shared captureLiveInfoSnapshot utility.
 */
function captureLiveInfoSnapshotForWash(betId: string, modeLabel: string | undefined, explanation: string): void {
  (async () => {
    try {
      const supabase = getSupabaseAdmin();
      const { data: betRow } = await supabase
        .from('bet_proposals')
        .select('mode_key, league, league_game_id')
        .eq('bet_id', betId)
        .maybeSingle();

      const modeKey = (betRow?.mode_key as string) ?? modeLabel ?? 'unknown';
      const league = (betRow?.league as string) ?? 'NFL';
      const leagueGameId = (betRow?.league_game_id as string | null) ?? null;

      await captureLiveInfoSnapshot({
        betId,
        modeKey,
        leagueGameId,
        league: league as any,
        trigger: 'washed',
        outcomeDetail: explanation,
      });
    } catch (err) {
      logger.warn(
        { betId, error: err instanceof Error ? err.message : String(err) },
        'wash snapshot capture failed',
      );
    }
  })();
}
